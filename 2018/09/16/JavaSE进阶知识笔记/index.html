<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />










<meta name="description" content="1.String类一旦创建了String对象，那么它的值就无法改变了，如果要对字符串做很多修改，应该使用StringBuffer类和StringBuilder类。常用方法:int length():返回字串长度。char charAt(int index):返回指定索引处的 char 值。boolean equals(Object anObject):将此字符串与指定的对象比较。int index">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE进阶知识笔记">
<meta property="og:url" content="http://yoursite.com/2018/09/16/JavaSE进阶知识笔记/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.String类一旦创建了String对象，那么它的值就无法改变了，如果要对字符串做很多修改，应该使用StringBuffer类和StringBuilder类。常用方法:int length():返回字串长度。char charAt(int index):返回指定索引处的 char 值。boolean equals(Object anObject):将此字符串与指定的对象比较。int index">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-16T08:19:48.340Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaSE进阶知识笔记">
<meta name="twitter:description" content="1.String类一旦创建了String对象，那么它的值就无法改变了，如果要对字符串做很多修改，应该使用StringBuffer类和StringBuilder类。常用方法:int length():返回字串长度。char charAt(int index):返回指定索引处的 char 值。boolean equals(Object anObject):将此字符串与指定的对象比较。int index">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/16/JavaSE进阶知识笔记/"/>





  <title>JavaSE进阶知识笔记 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/iunique"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/16/JavaSE进阶知识笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaSE进阶知识笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-16T16:19:35+08:00">
                2018-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>1.String类<br>一旦创建了String对象，那么它的值就无法改变了，如果要对字符串做很多修改，应该使用StringBuffer类和StringBuilder类。<br>常用方法:<br>int length():返回字串长度。<br>char charAt(int index):返回指定索引处的 char 值。<br>boolean equals(Object anObject):将此字符串与指定的对象比较。<br>int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。<br>int indexOf(String str, int fromIndex):返回指定子字符串在此字符串中第一次出现处的索引，从指定的索<br>引开始。<br>String replace(char oldChar,char newChar):返回一个新的字符串，它是通过用newChar替换此字符串中出<br>现的所有oldChar得到的。<br>String substring(int beginIndex):返回一个新的字符串，它是此字符串的一个子字符串。<br>char[] toCharArray():将此字符串转换为一个新的字符数组。<br>String trim():返回字符串的副本，忽略前导空白和尾部空白。<br>int compareTo(String anotherString):按字典顺序比较两个字符串。<br>2.StringBuffer类和StringBuilder类<br>StringBuffer和StringBuilder类能够被多次的修改，并且不产生新的使用对象。<br>StringBuffer和StringBuilder之间最大的不同在于StringBuilder的方法不是线程安全的(不能同步访问)。<br>由于StringBuilder相较于StringBuffer有速度优势，所以大多数情况下还是建议使用StringBuilder类。然而应用程序要求线程安全的情况下，则必须使用StringBuffer类。<br>eg:<br>public class Test{<br>  public static void main(String args[]){<br>    StringBuffer sBuffer = new StringBuffer(“测试：”);<br>    sBuffer.append(“第一次增长，”);<br>    sBuffer.append(“第二次增长，”);<br>    sBuffer.append(“第三次增长”);<br>    System.out.println(sBuffer);<br>  }<br>}<br>主要方法:<br>public StringBuffer append(String s):将指定的字符串追加到此字符序列。<br>public StringBuffer reverse():将此字符序列用其反转形式取代。<br>public delete(int start, int end):移除此序列的子字符串中的字符。<br>public insert(int offset, int i):将 int 参数的字符串表示形式插入此序列中。<br>replace(int start, int end, String str):使用给定 String 中的字符替换此序列的子字符串中的字符。<br>其余的方法大部分和String类的相同<br>3.Arrays类<br>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。<br>具有以下功能：<br>给数组赋值：通过 fill 方法。<br>对数组排序：通过 sort 方法,按升序。<br>比较数组：通过 equals 方法比较数组中元素值是否相等。<br>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。<br>4.IO<br>Java 的控制台输入由 System.in 完成。为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。<br>eg:<br>读取单个字符:<br>import java.io.<em>;<br>public class BRRead {<br>    public static void main(String args[]) throws IOException {<br>        char c;<br>        // 使用 System.in 创建 BufferedReader<br>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<br>        System.out.println(“输入字符, 按下 ‘q’ 键退出。”);<br>        // 读取字符<br>        do {<br>            c = (char) br.read();<br>            System.out.println(c);<br>        } while (c != ‘q’);<br>    }<br>}<br>读取字符串:<br>import java.io.</em>;<br>public class BRReadLines {<br>    public static void main(String args[]) throws IOException {<br>        // 使用 System.in 创建 BufferedReader<br>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<br>        String str;<br>        System.out.println(“Enter lines of text.”);<br>        System.out.println(“Enter ‘end’ to quit.”);<br>        do {<br>            str = br.readLine();<br>            System.out.println(str);<br>        } while (!str.equals(“end”));<br>    }<br>}<br>5.文件流<br>(1)FileInputStream<br>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>有多种构造方法可用来创建对象。<br>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：<br>InputStream f = new FileInputStream(“C:/java/hello”);<br>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：<br>File f = new File(“C:/java/hello”);<br>InputStream out = new FileInputStream(f);</p>
<p>主要方法:<br>public void close() throws IOException{}：关闭此文件输入流并释放与此流有关的所有系统资源。<br>抛出IOException异常。<br>protected void finalize()throws IOException{}这个方法清除与该文件的连接。确保在不再引用文 件输入流时调用其 close 方法。抛出IOException异常。<br>public int read(int r)throws IOException{}:这个方法从InputStream对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。<br>public int read(byte[] r) throws IOException{}:这个方法从输入流读取r.length长度的字节。<br>返回读取的字节数。如果是文件结尾则返回-1。<br>public int available() throws IOException{}返回下一次对此输入流调用的方法可以不受阻塞地从<br>此输入流读取的字节数。返回一个整数值。<br>(2)FileOutputStream<br>该类用来创建一个文件并向文件中写数据。<br>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。<br>有两个构造方法可以用来创建 FileOutputStream 对象。<br>使用字符串类型的文件名来创建一个输出流对象：<br>OutputStream f = new FileOutputStream(“C:/java/hello”)<br>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：<br>File f = new File(“C:/java/hello”);<br>OutputStream f = new FileOutputStream(f);<br>常用方法:<br>public void close() throws IOException{}:关闭此文件输入流并释放与此流有关的所有系统资源。<br>抛出IOException异常。<br>protected void finalize()throws IOException{}：这个方法清除与该文件的连接。确保在不再引用<br>文件输入流时调用其close 方法。抛出IOException异常。<br>public void write(int w)throws IOException{}:这个方法把指定的字节写到输出流中。<br>public void write(byte[] w):把指定数组中w.length长度的字节写到OutputStream中。<br>eg：<br>import java.io.<em>;<br>public class fileStreamTest {<br>    public static void main(String args[]) {<br>        try {<br>            byte bWrite[] = { 11, 21, 3, 40, 5 };<br>            OutputStream os = new FileOutputStream(“test.txt”);<br>            for (int x = 0; x &lt; bWrite.length; x++) {<br>                os.write(bWrite[x]); // writes the bytes<br>            }<br>            os.close();<br>            InputStream is = new FileInputStream(“test.txt”);<br>            int size = is.available();<br>            for (int i = 0; i &lt; size; i++) {<br>                System.out.print((char) is.read() + “  “);<br>            }<br>            is.close();<br>        } catch (IOException e) {<br>            System.out.print(“Exception”);<br>        }<br>    }<br>}<br>解决乱码问题:<br>import java.io.</em>;<br>public class fileStreamTest2 {<br>    public static void main(String[] args) throws IOException {<br>        File f = new File(“a.txt”);<br>        FileOutputStream fop = new FileOutputStream(f);<br>        // 构建FileOutputStream对象,文件不存在会自动新建<br>        OutputStreamWriter writer = new OutputStreamWriter(fop, “UTF-8”);<br>        // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk<br>        writer.append(“中文输入”);<br>        // 写入到缓冲区<br>        writer.append(“\r\n”);<br>        // 换行<br>        writer.append(“English”);<br>        // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入<br>        writer.close();<br>        // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉<br>        fop.close();<br>        // 关闭输出流,释放系统资源<br>        FileInputStream fip = new FileInputStream(f);<br>        // 构建FileInputStream对象<br>        InputStreamReader reader = new InputStreamReader(fip, “UTF-8”);<br>        // 构建InputStreamReader对象,编码与写入相同<br>        StringBuffer sb = new StringBuffer();<br>        while (reader.ready()) {<br>            sb.append((char) reader.read());<br>            // 转成char加到StringBuffer对象中<br>        }<br>        System.out.println(sb.toString());<br>        reader.close();<br>        // 关闭读取流<br>        fip.close();<br>        // 关闭输入流,释放系统资源<br>    }<br>}<br>6.Scanner类<br>Java Scanner 类<br>java.util.Scanner 是 Java5 的新特征，我们可以通过Scanner类来获取用户的输入。<br>创建Scanner对象的基本语法：<br>Scanner s = new Scanner(System.in);<br>演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine()方法获取输入的字符串，<br>在读取前我们一般需要使用 hasNext 与 hasNextLine 判断是否还有输入的数据：<br>import java.util.Scanner;<br>public class ScannerDemo {<br>    public static void main(String[] args) {<br>        Scanner scan = new Scanner(System.in);<br>        // 从键盘接收数据</p>
<pre><code>    // next方式接收字符串
    System.out.println(&quot;next方式接收：&quot;);
    // 判断是否还有输入
    if (scan.hasNext()) {
        String str1 = scan.next();
        System.out.println(&quot;输入的数据为：&quot; + str1);
    }
    scan.close();
}
</code></pre><p>}<br>使用nextLine方法:<br>import java.util.Scanner;<br>public class ScannerDemo {<br>    public static void main(String[] args) {<br>        Scanner scan = new Scanner(System.in);<br>        // 从键盘接收数据</p>
<pre><code>    // nextLine方式接收字符串
    System.out.println(&quot;nextLine方式接收：&quot;);
    // 判断是否还有输入
    if (scan.hasNextLine()) {
        String str2 = scan.nextLine();
        System.out.println(&quot;输入的数据为：&quot; + str2);
    }
    scan.close();
}
</code></pre><p>}<br>next() 与 nextLine() 区别<br>next():<br>1)一定要读取到有效字符后才可以结束输入。<br>2)对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>3)只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。<br>nextLine()：<br>1)以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>2)可以获得空白。<br>如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读。<br>eg:<br>import java.util.Scanner;<br>public class ScannerDemo {<br>    public static void main(String[] args) {<br>        Scanner scan = new Scanner(System.in);<br>        // 从键盘接收数据<br>        int i = 0;<br>        float f = 0.0f;<br>        System.out.print(“输入整数：”);<br>        if (scan.hasNextInt()) {<br>            // 判断输入的是否是整数<br>            i = scan.nextInt();<br>            // 接收整数<br>            System.out.println(“整数数据：” + i);<br>        } else {<br>            // 输入错误的信息<br>            System.out.println(“输入的不是整数！”);<br>        }<br>        System.out.print(“输入小数：”);<br>        if (scan.hasNextFloat()) {<br>            // 判断输入的是否是小数<br>            f = scan.nextFloat();<br>            // 接收小数<br>            System.out.println(“小数数据：” + f);<br>        } else {<br>            // 输入错误的信息<br>            System.out.println(“输入的不是小数！”);<br>        }<br>        scan.close();<br>    }<br>}<br>7.集合框架<br>(1)集合接口<br>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。<br>1)Collection 接口存储一组不唯一，无序的对象。<br>2)List 接口<br>List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。<br>List 接口存储一组不唯一，有序（插入顺序）的对象。<br>3)Set<br>Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。<br>Set 接口存储一组唯一，无序的对象。<br>4)SortedSet<br>继承于Set保存有序的集合。<br>5)Map<br>Map 接口存储一组键值对象，提供key（键）到value（值）的映射。<br>6)Map.Entry<br>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。<br>7)SortedMap<br>继承于 Map，使 Key 保持在升序排列。<br>8)Enumeration<br>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代<br>Set和List的区别</p>
<ol>
<li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。</li>
<li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。<br>(2)集合实现类<br>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。<br>标准集合类：<br>1)AbstractCollection:实现了大部分的集合接口。<br>2)AbstractList:继承于AbstractCollection 并且实现了大部分List接口。<br>3)AbstractSequentialList:继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。<br>4）LinkedList:该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：<br>Listlist=Collections.synchronizedList(newLinkedList(…));<br>LinkedList 查找效率低。<br>5)ArrayList:该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。<br>6)AbstractSet:继承于AbstractCollection 并且实现了大部分Set接口。<br>7)HashSet:该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。<br>8)LinkedHashSet:具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。<br>9)TreeSet:该类实现了Set接口，可以实现排序等功能。<br>10)AbstractMap:实现了大部分的Map接口。<br>11)HashMap:HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。<br>12)TreeMap:继承了AbstractMap，并且使用一颗树。<br>13)WeakHashMap:继承AbstractMap类，使用弱密钥的哈希表。<br>14)LinkedHashMap:继承于HashMap，使用元素的自然顺序对元素进行排序.<br>15)IdentityHashMap:继承AbstractMap类，比较文档时使用引用相等。<br>java.util包中定义的类<br>1)Vector:该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。<br>2)Stack:栈是Vector的一个子类，它实现了一个标准的后进先出的栈。<br>3)Dictionary:Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。<br>4)Hashtable:Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。<br>5)Properties:Properties 继承于Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是<br>一个字符串。<br>6)BitSet:一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。<br>(3)集合遍历方法<br>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。<br>一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。<br>迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。<br>eg:<br>import java.util.*;<br>public class Test{<br>public static void main(String[] args) {<br>  List<string> list=new ArrayList<string>();<br>  list.add(“Hello”);<br>  list.add(“World”);<br>  list.add(“HAHAHAHA”);<br>  //第一种遍历方法使用foreach遍历List<br>  for (String str : list) {            //也可以改写for(int i=0;i&lt;list.size();i++)这种形式<pre><code>System.out.println(str);
</code></pre>  }<br>  //第二种遍历，把链表变为数组相关的内容进行遍历<br>  String[] strArray=new String[list.size()];<br>  list.toArray(strArray);<br>  for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为  foreach(String str:strArray)这种形式<br>  {<pre><code>System.out.println(strArray[i]);
</code></pre>  }<br> //第三种遍历 使用迭代器进行相关遍历<br>  Iterator<string> ite=list.iterator();<br>  while(ite.hasNext())//判断下一个元素之后有值<br>  {<pre><code>System.out.println(ite.next());
</code></pre>  }<br>}<br>}<br>遍历Map:<br>import java.util.*;</string></string></string></li>
</ol>
<p>public class Test{<br>     public static void main(String[] args) {<br>      Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>      map.put(“1”, “value1”);<br>      map.put(“2”, “value2”);<br>      map.put(“3”, “value3”);<br>      //第一种：普遍使用，二次取值<br>      System.out.println(“通过Map.keySet遍历key和value：”);<br>      for (String key : map.keySet()) {<br>       System.out.println(“key= “+ key + “ and value= “ + map.get(key));<br>      }<br>      //第二种<br>      System.out.println(“通过Map.entrySet使用iterator遍历key和value：”);<br>      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();<br>      while (it.hasNext()) {<br>       Map.Entry&lt;String, String&gt; entry = it.next();<br>       System.out.println(“key= “ + entry.getKey() + “ and value= “ + entry.getValue());<br>      }<br>      //第三种：推荐，尤其是容量大时<br>      System.out.println(“通过Map.entrySet遍历key和value”);<br>      for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {<br>       System.out.println(“key= “ + entry.getKey() + “ and value= “ + entry.getValue());<br>      }<br>      //第四种<br>      System.out.println(“通过Map.values()遍历所有的value，但不能遍历key”);<br>      for (String v : map.values()) {<br>       System.out.println(“value= “ + v);<br>      }<br>     }<br>}</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/10/JVM学习笔记-三/" rel="next" title="JVM学习笔记(三)">
                <i class="fa fa-chevron-left"></i> JVM学习笔记(三)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpeg"
                alt="hjy" />
            
              <p class="site-author-name" itemprop="name">hjy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hjy</span>

  
</div>


  <div class="powered-by">
  <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
