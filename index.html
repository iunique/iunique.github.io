<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/iunique"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/Redis学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/Redis学习笔记/" itemprop="url">Redis学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T15:36:55+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.Redis是一个高性能的key-value数据库<br>Redis与其他的key-value缓存产品有以下三个特点:<br>(1)支持数据的持久化，可用将内存中的数据保存在磁盘中，重启的时候可用再次加载使用<br>(2)不仅支持简单的key-value类型的数据，同时提供list，set，zset，hash等数据结构储存<br>(3)Redis支持数据的备份<br>2.Redis优势<br>性能极高，读写速度快，有着丰富的数据类型操作，所有操作都是原子性的，即要么成功执行要么<br>失败完全不执行，多个操作也支持事务，有着丰富的特性。<br>3.安装<br>$sudo apt-get update<br>$sudo apt-get install redis-server<br>启动 Redis<br>$ redis-server<br>查看 redis 是否启动:<br>$ redis-cli<br>以上命令将打开以下终端：<br>redis 127.0.0.1:6379&gt;<br>127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。<br>redis 127.0.0.1:6379&gt; ping<br>PONG<br>以上说明我们已经成功安装了redis<br>4.Redis配置<br>redis 127.0.0.1:6379&gt; CONFIG GET 配置项名<br>可以查看相应的配置信息，可以通过修改redis.conf文件(默认在/etc/redis里)或使用config set命令来修改<br>语法:config set 配置项名 修改的值<br>5.Redis数据类型简介<br>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)<br>(1)String<br>string是redis最基本的类型，一个key对应一个value，string类型是二进制安全的，redis的string可以包<br>含任何数据，比如jpg图像或者序列化对象。string类型的值最大能储存512MB。<br>eg:<br>redis 127.0.0.1:6379&gt; SET name “hjy”<br>OK<br>redis 127.0.0.1:6379&gt; GET name<br>“hjy”<br>(2)Hash<br>hash是一个键值对集合，有点像c++里面的map，是一个string类型的field和value的映射表，特别适合用于<br>储存对象,使用hmset，hget来设置，获取值。<br>eg:<br>redis&gt; HMSET myhash field1 “Hello” field2 “World”<br>“OK”<br>redis&gt; HGET myhash field1<br>“Hello”<br>redis&gt; HGET myhash field2<br>“World”<br>(3)List<br>列表是简单的字符串列表，按照插入顺序排序，可以添加一个元素在列表的头部或者尾部。<br>eg:<br>redis 127.0.0.1:6379&gt; lpush runoob redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; lpush runoob mongodb<br>(integer) 2<br>redis 127.0.0.1:6379&gt; lpush runoob rabitmq<br>(integer) 3<br>redis 127.0.0.1:6379&gt; lrange runoob 0 10<br>1) “rabitmq”<br>2) “mongodb”<br>3) “redis”<br>其中runoob为list的名字，lpush表示往runoob插入一个redis的value<br>lrange表示罗列出list一定范围内的元素<br>(4)Set<br>表示string类型的无序集合，是通过哈希表实现的,所以添加，删除，查找的复杂度都是O(1)<br>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回<br>0，如果 key 对应的 set 不存在则返回错误，通过sadd往set中添加元素:<br>sadd key member<br>eg：<br>redis 127.0.0.1:6379&gt; sadd runoob redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd runoob mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd runoob rabitmq<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd runoob rabitmq<br>(integer) 0<br>redis 127.0.0.1:6379&gt; smembers runoob<br>1) “redis”<br>2) “rabitmq”<br>3) “mongodb”<br>以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略<br>(5)zset<br>zset也和set一样是string类型元素的集合，且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数，通过分数为集合中的成员进行从小到达排序。<br>zset的成员是唯一的，但分数可用重复，通过zadd添加元素到集合，元素在集合中存在则更新<br>对应score:<br>zadd key score member<br>eg：<br>redis 127.0.0.1:6379&gt; zadd runoob 0 redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq<br>(integer) 0<br>redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 1000<br>1) “mongodb”<br>2) “rabitmq”<br>3) “redis”<br>6.Rdeis命令<br>客户端启动命令:redis-cli<br>检测redis是否启动:ping，返回pong则启动<br>在远程服务上执行命令:<br>redis-cli -h host -p port -a password<br>eg:<br>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上<br>$redis-cli -h 127.0.0.1 -p 6379 -a “mypass”<br>redis 127.0.0.1:6379&gt;<br>redis 127.0.0.1:6379&gt; PING<br>PONG<br>有时候会有中文乱码<br>要在 redis-cli 后面加上 –raw<br>redis-cli –raw<br>就可以避免中文乱码了<br>7.Redis键命令<br>Redis 键命令的基本语法如下：<br>redis 127.0.0.1:6379&gt; COMMAND KEY_NAME<br>eg:<br>redis 127.0.0.1:6379&gt; SET runoobkey redis<br>OK<br>redis 127.0.0.1:6379&gt; DEL runoobkey<br>(integer) 1<br>DEL 是一个命令， runoobkey 是一个键。 如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0<br>常用的几个：<br>DEL key:该命令用于在 key 存在时删除 key<br>DUMP key:序列化给定 key ，并返回被序列化的值<br>EXISTS key:检查给定 key 是否存在<br>EXPIRE key seconds:为给定 key 设置过期时间<br>MOVE key db:将当前数据库的 key 移动到给定的数据库 db 当中<br>PERSIST key:移除 key 的过期时间，key 将持久保持<br>PTTL key:以毫秒为单位返回 key 的剩余的过期时间<br>TTL key:以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)<br>RENAME key newkey:修改 key 的名称<br>RENAMENX key newkey:仅当 newkey 不存在时，将 key 改名为 newkey 。<br>TYPE key:返回 key 所储存的值的类型<br>8.String<br>字符串常用命令:<br>SET key value:设置指定 key 的值<br>GET key:获取指定 key 的值<br>GETRANGE key start end:返回 key 中字符串值的子字符<br>GETSET key value:将给定 key 的值设为 value ，并返回 key 的旧值(old value)<br>MGET key1 [key2..]:获取所有(一个或多个)给定 key 的值<br>SETEX key seconds value:将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)<br>SETNX key value:只有在 key 不存在时设置 key 的值<br>STRLEN key:返回 key 所储存的字符串值的长度<br>INCRBY key increment:将 key 所储存的值加上给定的增量值(increment)<br>DECRBY key decrement:key 所储存的值减去给定的减量值(decrement)<br>APPEND key value:如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾<br>9.Hash<br>eg:<br>127.0.0.1:6379&gt;  HMSET runoobkey name “redis tutorial” description “redis basic commands for caching” likes 20 visitors 23000<br>OK<br>127.0.0.1:6379&gt;  HGETALL runoobkey<br>1) “name”<br>2) “redis tutorial”<br>3) “description”<br>4) “redis basic commands for caching”<br>5) “likes”<br>6) “20”<br>7) “visitors”<br>8) “23000”<br>hash常用命令:<br>HDEL key field1 [field2]:删除一个或多个哈希表字段<br>HEXISTS key field:查看哈希表 key 中，指定的字段是否存在<br>HGET key field:获取存储在哈希表中指定字段的值<br>HGETALL key:获取在哈希表中指定 key 的所有字段和值<br>INCRBY key field increment:为哈希表 key 中的指定字段的整数值加上增量 increment<br>HKEYS key:获取所有哈希表中的字段<br>HLEN key:获取哈希表中字段的数量<br>HMGET key field1 [field2]:获取所有给定字段的值<br>HMSET key field1 value1 [field2 value2 ]:同时将多个 field-value (域-值)对设置到哈希表key中<br>HSET key field value:将哈希表 key 中的字段 field 的值设为 value<br>HVALS key:获取哈希表中所有值<br>10.List<br>列表命令:<br>BLPOP key1 [key2 ] timeout:移出并获取列表的第一个元素,如果列表没有元素会阻塞列表直到等待超<br>时或发现可弹出元素为止<br>LINDEX key index:通过索引获取列表中的元素<br>LINSERT key BEFORE|AFTER pivot value:在列表的元素前或者后插入元素<br>LLEN key:获取列表长度<br>LPOP key:移出并获取列表的第一个元素<br>LPUSH key value1 [value2]:将一个或多个值插入到列表头部<br>LRANGE key start stop:获取列表指定范围内的元素<br>LREM key count value:移除列表元素<br>LSET key index value:通过索引设置列表元素的值<br>RPOP key:移除并获取列表最后一个元素<br>RPUSH key value1 [value2]:在列表中添加一个或多个值<br>11.Set<br>集合命令:<br>SADD key member1 [member2]:向集合添加一个或多个成员<br>SCARD key:获取集合的成员数<br>SDIFF key1 [key2]:返回给定所有集合的差集<br>SINTER key1 [key2]:返回给定所有集合的交集<br>SISMEMBER key member:判断 member 元素是否是集合 key 的成员<br>SMEMBERS key:返回集合中的所有成员<br>SMOVE source destination member:将 member 元素从 source 集合移动到 destination 集合<br>SREM key member1 [member2]:移除集合中一个或多个成员<br>SUNION key1 [key2]:返回所有给定集合的并集<br>12.sorted set<br>有序集合命令:<br>ZADD key score1 member1 [score2 member2]:向有序集合添加一个或多个成员，或者更新已存在成<br>员的分数<br>ZCARD key:获取有序集合的成员数<br>ZINCRBY key increment member:有序集合中对指定成员的分数加上增量 increment<br>ZCOUNT key min max:计算在有序集合中指定区间分数的成员数<br>ZLEXCOUNT key min max:在有序集合中计算指定字典区间内成员数量<br>ZRANGE key start stop [WITHSCORES]:通过索引区间返回有序集合成指定区间内的成员<br>ZRANGEBYLEX key min max [LIMIT offset count]:通过字典区间返回有序集合的成员<br>ZSCORE key member:返回有序集中，成员的分数值<br>ZREVRANK key member:返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序<br>…好多，看的眼花缭乱，要用的时候搜一下吧</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/JVM学习笔记-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/JVM学习笔记-一/" itemprop="url">JVM学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T11:41:12+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看《深入理解Java虚拟机》，第一章说是自己编写个JDK，看的云里雾里就跳掉了，两天马马虎虎才看完了第二章，下面是自己写的笔记。</p>
<p>1.Java程序设计语言，Java虚拟机，JavaAPI类库这三部分统称为JDK(Java Development),JDK是用于支持Java程序开发的最小环境<br>2.可以把JavaAPI类库中的Java SE API子集和Java虚拟机这两部分统称为JRE<br>(Java Runtime Environment),JRE是支持Java程序运行的标准环境<br>3.根据各个组成部分的功能来划分，可用分为4个平台<br>(1)Java Card:支持一些Java小程序运行再小内存设备上的平台<br>(2)Java ME:支持Java程序运行在移动终端上的平台<br>(3)Java SE:支持面向桌面级的应用，提供了完整的Java核心API<br>(4)Java EE:支持使用多层架构的企业引用，除了提供Java SE外，还做了大量<br>的扩充并提供了相关的部署支持<br>4.运行时数据区域<br>Java在运行程序时会将它所管理的内存划分为若干个不同的数据区域<br>(1)程序计数器<br>可以看作是当前线程所执行字节码的行号指示器，字节码解释器工作就是通过改变计数器的值<br>来选取下一条需要执行的字节码命令。一个处理器都只会执行一条线程中的命令，每条线程都<br>需要有一个独立的程序计数器，各线程的计数器之间互不影响，独立存储。如果线程正在执行<br>的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令代码。如果正在执行的<br>是Native方法，这个计数器值为空，此内存区域是唯一一个在Java虚拟机规范中没有任何规<br>定的OutOfMemoryError情况的区域。<br>(2)Java虚拟机栈<br>与计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是<br>Java方法执行的内存模型:每个方法再执行的同时都会创建一个栈帧，用于储存局部变量表，<br>操作数栈，动态链接，方法出口等信息，每个方法从调用至执行的过程中，就对应这一个栈帧<br>在虚拟机栈中入栈到出栈的过程。局部变量所需的内存空间在编译期间完成分配，当进入一个<br>方法时，所需要在帧中的分配多大的局部空间是完全确定的，方法运行期间不会改变局部变量<br>表的大小。这个区域规定了两种异常:如果线程请求栈深度大于虚拟机所允许的深度，将抛出<br>StackOverflowError异常，如果虚拟机栈可用动态扩展，扩展时无法申请到足够的内存，<br>就会抛出OutOfMemoryError异常。<br>(3)本地方法栈<br>本地方法栈和Java虚拟机栈的作用非常相似，区别只是虚拟机栈为执行Java方法服务，本地<br>方法栈则为虚拟机使用的Native方法服务。在虚拟机规范中对本地方法栈中使用的语言没有<br>强制规定，因此具体的虚拟机可以自由实现它。与虚拟机栈一样本地方法栈也会抛出<br>StackOverflowError异常和OutOfMemory异常。<br>(4)Java堆<br>Java堆是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一片区域。此内存区域<br>的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾管理器<br>管理的主要区域，因此很多时候也被称作“GC堆”。从内存分配的角度来看，Java堆可用划分出<br>多个线程私有的分配缓冲区，无论怎么划分，都与存放内容无关，存储的仍然是对象实例，进一步<br>划分是为了更好的回收内存，或者更快得分配内存。Java堆可用处于物理上不连续的内存空间中，<br>只要逻辑上是连续的即可，如果在堆中没有内存完成实例分配，并且堆也无法扩展时，将会抛出<br>OutOfMemoryError异常。<br>(5)方法区<br>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态<br>变量等数据。虽然Java虚拟机规范把堆描述为堆的一个逻辑部分，但是它有一个别名叫做”Non-Heap”<br>即非堆，目的是与Java堆区分开来。Java虚拟机堆方法区的限制非常宽松，除了和Java堆一样不需要<br>连续的内存即可选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集在<br>这个区域是比较少出现的，这个区域主要是针对常量池的回收和对类型的卸载，条件相当苛刻。Java<br>虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br>(6)运行时常量池<br>运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还<br>有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方<br>法区的运行时常量池中存放。对于运行常量池，Java虚拟机规范没有做任何细节要求，不同的提供商<br>可以按照自己的需要来实现这个内存区域。运行时常量池还有一个重要特征是具备动态性，Java语言<br>常量不一定只有在编译期间才能产生，也就是并非预置入Class文件中常量池的内容才能进入运行时<br>常量池，运行期间也可能将新的常量放入池中，这种特效被开发人员用的最多的是String类的intern<br>方法。当常量池无法申请到内存时会抛出OutOfMemoryError异常。<br>5.直接内存<br>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分<br>内存也被频繁地使用，在JDK1.4中新引入了NIO(new Input/Output)类，引入了一种基于通道与<br>缓存区的I/O方式，可用使用Native函数库直接分配堆外内存，然后用过一个存储在Java堆中的<br>DirectByteBuffer对象作为这块内存的引用进行操作，避免了Java堆和Native堆中来回复制数据，<br>在一些应用场景中显著提高性能。当直各个内存区域总和大于物理内存限制时会抛出OutOfMemoryError<br>异常。<br>6.对象的创建<br>当虚拟机遇到一条new命令时，先去检查这个命令参数能否在常量池中定位到一个类的符号引用，并且检查<br>这个符号引用代表的类是否已被加载，解析，初始化过，如果没有，则必须先执行相应的类加载过程。之后，<br>虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可完全确定，为对象分配内存空间相当于把一<br>块确定大小的内存从Java堆中划分出来。划分可用空间一般有两种方法，一种是“指针碰撞”，另一种是<br>“空闲列表”，选择哪种分配方式由Java堆是否规整决定，而其又由所采用的垃圾收集器是否带有压缩整理<br>功能决定。对象的创建是虚拟机中非常频繁的行为，即使只是修改一个指针指向的位置，在并发的情况下也<br>不是线程安全的，可能出现正在给对象分配内存，指针还没来得及修改，另一个对象又使用了原来的指针分配<br>内存的情况。解决这个问题有两种方案，一是堆分配内存的动作进行同步处理，另一种是把内存分配的动作<br>划分在不同的空间之中进行，即每个线程在Java堆中预先分配一块小的内存，被称为本地线程分配缓冲(TLAB)<br>哪个线程需要分配内存，就在哪个线程的TLAB上分配。内存分配完后，虚拟机要将分配的内存空间都初始化为0,<br>这一操作保证了对象实例再Java代码中可以不赋值就使用。接下来虚拟机要对对象信息进行必要的设置，这些信息<br>存放在对象头之中。从虚拟机的视角上看，一个对象已经产生了，但从Java程序的视角上看，还需要执行<init><br>方法对对象进行初始化，一个真正可用的对象才算完全产生出来。<br>7.对象的内存布局<br>对象在内存中的存储布局可以分为3块区域:对象头，实例数据和对齐填充。<br>(1)对象头<br>对象头包括两部分信息，第一部分用于存储对象自身运行时数据，如哈希码，GC分代年龄，锁状态标志等。对象头<br>的另一部分是类型指针，即对象指向它的类元数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。不是<br>所有虚拟机实现都必须在对象数据上保留类型指针，如果对象是数组，对象头中还必须有一块用于记录数组长度的数据。<br>(2)实例数据<br>实例数据部分是对象真正存储的有效信息，也是程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，<br>还是在子类中定义的，都需要记录下来。这部分的存储顺序会受虚拟机分配策略参数和字段在Java中的定义顺序的<br>影响。<br>(3)对齐填充<br>这一部分并不是必然存在的，也没有特别的含义，仅起着占位符的作用，当对象实例数据部分没有对齐时，就需要通<br>过对齐填充来补全。<br>8.对象的访问定位<br>Java程序需要通过栈上的reference数据来操作堆上的具体对象。对象访问方式取决于虚拟机的实现，目前主流的<br>访问方式有使用句柄和直接指针两种。<br>(1)使用句柄<br>Java堆中将会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据<br>与类型数据各自的具体地址信息<br>(2)直接指针访问<br>Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。<br>两种访问方式各自的优点:<br>使用句柄访问最大的好处就是reference中存储的是稳定的句柄地址，对象被移动(垃圾收集时移动对象是非常普遍<br>的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。<br>9.OutOfMemoryError异常<br>(1)Java堆溢出<br>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制<br>清楚这些对象，那么对象数量达到最大堆的容量限制后就会产生内存溢出异常。当Java堆内存溢出时，异常堆信息<br>会进一步提示”Java heap space”。要解决这个区域的异常，一般是先通过内存影响分析工具对Dump出来的转<br>储快照进行分析，重点是确认内存中的对象是否必要的，先分清楚是发生了内存泄露还是内存溢出。如果是内存泄露，<br>可进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC Roots相关联<br>并导致垃圾收集器无法自动回收它们的。掌握了这些信息就可用比较准确地定位出泄露代码的位置。如果不存在泄露，<br>就是内存中的对象确实都还必须或者，就应当检查虚拟机的堆参数，与机器物理内存对比是否还可用调大，从代码上<br>检查是否存在某些生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗。<br>(2)虚拟机栈和本地方法栈溢出<br>Java虚拟机中描述了两种异常，如果线程请求栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError<br>异常，如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常。实验结果表明，无论<br>是栈帧太大还是虚拟机容量太小，当内存无法分配的时候，抛出的都是StackOverflowError异常。如果测试不限<br>于单线程，通过不断地建立线程的方式倒是可用产生内存溢出异常。建立过多线程导致的内存溢出，在不能减少线程数<br>或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。<br>(3)方法区和运行时常量池溢出<br>运行时常量池是方法区的一部分，当前的主流框架如Spring，Hibernate在对类进行增强时，会使用到GCLib这类<br>字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可用加载入内存，经常会出现这类问题。在<br>经常动态生成大量Class的应用中，需要特别注意类的回收状况，除了GCLib和动态语言之外，常见的还有JSP或者动态<br>生成JSP的应用，基于OSGi的应用。<br>(4)本机直接内存溢出<br>当代码越过DirectBytesBuffer类，直接通过反射获取实例进行内存分配时会产生该异常，因为虽然使用<br>DirectBytesBuffer分配内存也会抛出内存溢出异常，但抛出的异常并没有真正向操作系统申请分配内存，<br>而是手动计算得知内存无法分配，手动抛出异常，由DirectBytesBuffer导致的内存溢出，一个明显的特征是<br>Heap Dump文件中不会看见明显的异常。</init></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/python学习笔记-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/python学习笔记-二/" itemprop="url">python学习笔记(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T16:38:22+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>18.函数<br>abs函数，接收一个参数，返回其绝对值<br>max函数，可用接收任意多个参数，返回最大的<br>数据转化函数:<br>int,float,str,bool<br>可用把函数名赋值给一个变量，相当于给这个函数取了个别名<br>eg:<br>a = abs # 变量a指向abs函数<br>a(-1) # 所以也可以通过a调用abs函数,显示1<br>19.定义函数<br>使用def，依次写出函数名，括号，括号中的参数，冒号，在缩进块中写函数体，返回值用return语句返回<br>eg:<br>def my_abs(x):<br>    if x &gt;= 0:<br>        return x<br>    else:<br>        return -x<br>若没有return，也会返回结果，会是None，相当于return None<br>空函数:<br>如果想定义一个什么事也不做的空函数，可以用pass语句:<br>def nop():<br>    pass<br>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。<br>pass还可以用在其他语句里，比如：<br>if age &gt;= 18:<br>    pass<br>20.关于函数<br>可用用户isinstance函数检查数据类型:<br>def my_abs(x):<br>    if not isinstance(x, (int, float)):<br>        raise TypeError(‘bad operand type’)<br>    if x &gt;= 0:<br>        return x<br>    else:<br>        return -x<br> 返回多个值:<br> import math<br>def move(x, y, step, angle=0):<br>    nx = x + step <em> math.cos(angle)<br>    ny = y - step </em> math.sin(angle)<br>    return nx, ny<br>其实返回的是一个tuple<br>设置默认参数时，注意：<br>必选参数在前，默认参数在后，否则Python的解释器会报错<br>函数中对参数的改变不会改变原变量<br>注意:默认参数的变量也是一个变量，如果指向的是[]，如果改变[]的内容，默认内容就变了，通过将默认参数改为None可以解决<br>21.可变参数<br>参数的个数是可变的，由于参数个数不确定，首先讲参数作为一个list或tuple传进来<br>eg:<br>def calc(numbers):<br>    sum = 0<br>    for n in numbers:<br>        sum = sum + n <em> n<br>    return sum<br>调用时要组装成一个list后tuple:<br>calc([1, 2, 3])<br>calc((1, 3, 5, 7))<br>当一个list所有元素作为参数传入时，直接再名字前加</em><br>nums = [1, 2, 3]<br>calc(<em>nums)<br>22.关键字参数<br>关键字参数允许传入0个或任意个含参数名的参数，会在函数内部自动组装为一个dict<br>eg:<br>def person(name, age, <strong>kw):<br>    print(‘name:’, name, ‘age:’, age, ‘other:’, kw)<br>在调用该函数时，kw作为可选参数<br>输入:person(‘Michael’, 30)<br>输出:name: Michael age: 30 other: {}<br>输入:person(‘Adam’, 45, gender=’M’, job=’Engineer’)<br>输出:name: Adam age: 45 other: {‘gender’: ‘M’, ‘job’: ‘Engineer’}<br>输入：extra = {‘city’: ‘Beijing’, ‘job’: ‘Engineer’}<br>     person(‘Jack’, 24, </strong>extra)<br>输出:name: Jack age: 24 other: {‘city’: ‘Beijing’, ‘job’: ‘Engineer’}<br>23.命名关键字参数<br>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：<br>def person(name, age, </em>, city, job):<br>    print(name, age, city, job)<br>和关键字参数*<em>kw不同，命名关键字参数需要一个特殊分隔符</em>，<em>后面的参数被视为命名关键字参数。<br>调用方式:person(‘Jack’, 24, city=’Beijing’, job=’Engineer’)<br>24.参数组合<br>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。<br>25.切片<br>py提供切片来从一个list中截取一部分元素<br>eg:<br>L = [‘Michael’, ‘Sarah’, ‘Tracy’, ‘Bob’, ‘Jack’]<br>输入:L[0:3]<br>显示:[‘Michael’, ‘Sarah’, ‘Tracy’]<br>如果第一个数字是0可以省略:L[:3],也支持倒数切片L[-2：-1]<br>前十个数，每两个去一个写法:<br>L[:10:2]<br>所有数，每5个取一个:<br>L[::5]<br>只写L[:]可用原样复制一个list<br>元组也可用切片，切出的结果也为tuple<br>(-,1,2,3,4,5)[:3]<br>结果:(0,1,2)<br>26.迭代<br>for in循环:<br>d = {‘a’: 1, ‘b’: 2, ‘c’: 3}<br>for key in d:<br>    print(key)<br>当遍历dict时候，用value来取其值<br>for value in d.values()<br>如果要同时迭代key和value，写法:<br>for k, v in d.items()<br>如果想循环下标值，py有内置的enumerate函数:<br>for i, value in enumerate([‘A’, ‘B’, ‘C’]):<br>    print(i, value)<br>结果:<br>0 A<br>1 B<br>2 C<br>想再for循环中同时引用两个变量:<br>for x, y in [(1, 1), (2, 4), (3, 9)]:<br>    print(x, y)<br>27.列表生成式<br>生成[1</em>1,2<em>2,4</em>3..]写法:<br>L = []<br>for x in range(1, 11):<br>   L.append(x <em> x)<br>也可写成:<br>[x </em> x for x in range(1, 11)]<br>for循环后可以加上if判断来筛选出偶数的平方:<br>[x <em> x for x in range(1, 11) if x % 2 == 0]<br>结果:[4, 16, 36, 64, 100]<br>还可用两层循环生成全排列:<br>[m + n for m in ‘ABC’ for n in ‘XYZ’]<br>结果:[‘AX’, ‘AY’, ‘AZ’, ‘BX’, ‘BY’, ‘BZ’, ‘CX’, ‘CY’, ‘CZ’]<br>eg:用两个变量来生成list<br>d = {‘x’: ‘A’, ‘y’: ‘B’, ‘z’: ‘C’ }<br>[k + ‘=’ + v for k, v in d.items()]<br>结果:[‘y=B’, ‘x=A’, ‘z=C’]<br>28.生成器<br>一个列表的大小是有限的，如果创建一个很大的列表，每次却只访问前几个元素，那么绝大<br>多数的空间就被浪费了，generator就是为了解决这个问题，每次在循环的过程中不断推算出后续<br>的元素，这样不比创建完整的list，可以节省大量空间，这种一边循环一边计算的机制称为生成器<br>L = [x </em> x for x in range(10)]<br>g = (x <em> x for x in range(10))<br>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator<br>如果需要打印出每一个元素，可以通过next(g)打印出来<br>每次调用next(g)就会计算下一个元素的值，直到计算到最后一个元素，没有更多的元素时会抛出错误<br>但是一般不会使用next进行变量，可以使用for循环:<br>g = (x </em> x for x in range(10))<br>for n in g:<br>   print(n)<br>如果推算的算法比较赋值，for循环无法实现时，可用用函数来实现:<br>如，输出斐波拉契数列:<br>def fib(max):<br>    n, a, b = 0, 0, 1<br>    while n &lt; max:<br>        print(b)<br>        a, b = b, a + b<br>        n = n + 1<br>    return ‘done’<br>注意，赋值语句：<br>a, b = b, a + b<br>相当于：<br>t = (b, a + b) # t是一个tuple<br>a = t[0]<br>b = t[1]<br>调用:fib(6)<br>结果:<br>1<br>1<br>2<br>3<br>5<br>8<br>‘done’<br>如果要将上述函数变成generator，只需要讲print(b)变成yield b就可以了：<br>def fib(max):<br>    n, a, b = 0, 0, 1<br>    while n &lt; max:<br>        yield b<br>        a, b = b, a + b<br>        n = n + 1<br>    return ‘done’<br>generator和函数的执行流程不一样。函数是顺序执行，遇到return<br>语句或者最后一行函数语句就返回。而变成generator的函数，在每次<br>调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的<br>yield语句处继续执行。<br>eg:<br>def odd():<br>    print(‘step 1’)<br>    yield 1<br>    print(‘step 2’)<br>    yield(3)<br>    print(‘step 3’)<br>    yield(5)<br>o = odd()<br>调用:next(o)<br>输出:step 1<br>    1<br>调用:next(o)<br>输出:step 2<br>    3<br>调用:next(o)<br>输出:step 3<br>    5<br>用for循环调用generator时，发现拿不到generator的return语句的返回值。<br>如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在<br>StopIteration的value中：<br>g = fib(6)<br>while True:<br>     try:<br>         x = next(g)<br>         print(‘g:’, x)<br>     except StopIteration as e:<br>         print(‘Generator return value:’, e.value)<br>         break<br>g: 1<br>g: 1<br>g: 2<br>g: 3<br>g: 5<br>g: 8<br>Generator return value: done<br>29.迭代器<br>凡是可作用于for循环的对象都是Iterable类型；<br>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；<br>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。<br>Python的for循环本质上就是通过不断调用next()函数实现的<br>可以使用isinstance()判断一个对象是否是Iterable对象：</p>
<blockquote>
<blockquote>
<blockquote>
<p>from collections import Iterable<br>isinstance([], Iterable)<br>True<br>isinstance({}, Iterable)<br>True<br>isinstance(‘abc’, Iterable)<br>True<br>isinstance((x for x in range(10)), Iterable)<br>True<br>isinstance(100, Iterable)<br>False<br>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。<br>可以使用isinstance()判断一个对象是否是Iterator对象：<br>from collections import Iterator<br>isinstance((x for x in range(10)), Iterator)<br>True<br>isinstance([], Iterator)<br>False<br>isinstance({}, Iterator)<br>False<br>isinstance(‘abc’, Iterator)<br>False<br>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。<br>把list、dict、str等Iterable变成Iterator可以使用iter()函数：<br>isinstance(iter([]), Iterator)<br>True<br>isinstance(iter(‘abc’), Iterator)<br>True</p>
</blockquote>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/python学习笔记-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/python学习笔记-一/" itemprop="url">python学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T16:19:25+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.py交互模式<br>命令行下输入python进入交互模式，可写py代码，输入exit()再按回车退出交互模式<br>2.运行.py文件<br>python xx.py<br>3.Linux上直接运行.py脚本<br>在文件开头加上注释:#!/usr/bin/env python3<br>然后给该文件加上可执行权限:<br>chmod a+x xx.py<br>之后就可以./xx.py运行了<br>ps:总是报错说找不到env，度娘也找不到答案，感觉大概是系统装了太多版本的py<br>4.print()函数<br>打印出指定文字，把希望打印的文字用单引号或双引号括起来<br>接受多个字符串时用逗号隔开<br>py2会吧括号显示出来，py3就不会了<br>想打印出引号要加/作转义字符，//则显示/<br>如果很多字符不需要转义，加上r’xxxxx’<br>这之间的字符不会被转义<br>通常用print(‘’’<br>xx<br>xx<br>xx’’’)来表示多行内容<br>5.input()函数<br>name=input()可以直接接收输入字符串<br>name=input(‘请输入你的名字’)这样可以起到提示输入作用<br>input的返回值为str类型，若要当整数使用用int函数转换<br>6.布尔运算<br>值要么是True，要么是False<br>and表示与运算，or表示或运算，not表示非运算<br>7.动态语言特效<br>py运行给同一个变量赋不同类型的值，比如定义时:<br>a=123<br>a=‘ABC’<br>这样是允许的<br>通常全部大写表示常量，如PI<br>8.除法<br>/表示除法，即使结果为整数也会表示为浮点数<br>//表示地板除，结果永远为整数<br>9.字符编码<br>py3中采用的是Unicode编码<br>ord函数可以用来将字符转化为编码的整数表示<br>比如:ord(‘A’)就会得到A的Unicode编码65<br>ord(‘中’)可以得到编码20013<br>chr函数可以讲编码转换为对应的字符<br>chr(66)就可以得到B<br>chr(25991)可以得到文<br>一个字符对应若干字节，如果要在网络上传输，要将str变为字节单位bytes<br>bytes类型数据带前缀b加引号表示<br>x = b’ABC’<br>str字符串可以通过encode函数编码为指定的bytes<br>‘ABC’.encode(‘ascii’)<br>b’ABC’<br>这样将’ABC’用ascii的方式变为了bytes字节<br>注意：中文编码超过了ascii范围，要用utf-8或者gbk的方式来编译，否则报错<br>同理可以讲字节bytes通过decode来解码<br>len函数可以来求字串长度<br>py脚本为了让解释器按utf-8编码读取，通常在文件开头加上:</p>
<p>#!/usr/bin/env python3</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>第一行注释是为了告诉Linux系统，这是一个Python可执行程序，Windows系统会忽略这个注释；<br>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。<br>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码<br>10.格式化字串<br>占位符和c语言一致，输出时稍有不同<br>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)<br>结果:’Hi, Michael, you have $1000000.’<br>不确定类型时可用%s，它会讲任何数据类型转化为字符串<br>若要输出%，两个%可表示<br>format函数也可格式化字符串，它会讲传入参数依次替换占位符{0}，{1}，{2}…<br>‘Hello, {0}, 成绩提升了 {1:.1f}%’.format(‘小明’, 17.125)<br>结果:’Hello, 小明, 成绩提升了 17.1%’<br>可用用过replace函数将相应的字符串/字符替换:<br>a = ‘abc’<br>a.replace(‘a’, ‘A’)<br>注意只是函数返回的字串变了，a字串本身不变<br>11.list<br>classmates = [‘Michael’, ‘Bob’, ‘Tracy’]<br>classmates就是一个list，可用用len(classmates)来求其元素个数<br>classmates[0],classmates[1]..可用依次取用这些元素<br>classmates[-1]可用直接取最后一个元素，-2，,-3同理<br>可用通过append函数往list中添加元素<br>classmates.append(‘Adam’)往末尾添加了一个元素<br>也可以添加入指定位置:<br>classmates.insert(1,’jack’)<br>pop函数不加参数可以删除末尾元素，classmates.pop(1)则会删掉索引为1的元素<br>可用直接赋值替换掉元素内容，各个元素类型可用不同，可用是一个变量，元素也可以是一个list<br>12.tuple<br>tuple叫做元祖，也是一种有序元组，和list相似，但是tuple一旦初始化便不能再修改，没有append和insert这种函数，可正常使用classmates[0]这种元素，但不能进行修改，tuple使得代码更安全<br>t = (1,2)<br>如果要定义一个空元组<br>写成<br>t = ()<br>只有一个元素时，为了和数学的小括号区分，写成<br>t = (1,)<br>当tuple元素为list时list元素可变<br>13.判断语句<br>eg1:<br>age = 3<br>if age &gt;= 18:<br>    print(‘your age is’, age)<br>    print(‘adult’)<br>else:<br>    print(‘your age is’, age)<br>    print(‘teenager’)<br>eg2:<br>age = 3<br>if age &gt;= 18:<br>    print(‘adult’)<br>elif age &gt;= 6:<br>    print(‘teenager’)<br>else:<br>    print(‘kid’)<br>14.循环语句<br>for-in循环:<br>eg:<br>names = [‘Michael’, ‘Bob’, ‘Tracy’]<br>for name in names:<br>    print(name)<br>计算1-10的和：<br>names = [‘Michael’, ‘Bob’, ‘Tracy’]<br>for name in names:<br>    print(name)<br>计算1-100的和，可用range函数，会生成一个整数序列，再通过list函数转化为list：<br>sum = 0<br>for x in range(101):<br>    sum = sum + x<br>print(sum)<br>15.break和continue<br>和c语言相同,一般配合if使用<br>eg1:<br>n = 1<br>while n &lt;= 100:<br>    if n &gt; 10: # 当n = 11时，条件满足，执行break语句<br>        break # break语句会结束当前循环<br>    print(n)<br>    n = n + 1<br>print(‘END’)<br>eg2:<br>n = 0<br>while n &lt; 10:<br>    n = n + 1<br>    if n % 2 == 0: # 如果n是偶数，执行continue语句<br>        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行<br>    print(n)<br>16.dict<br>py内置的字典dict，其他语言中成为map键值对，具有极快的查找速度<br>eg:<br>d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}<br>d[‘Michael’]则显示95<br>放入字典中除了初始化赋值，也可以直接赋值：<br>d[‘Adam’] = 67<br>用’Thomas’ in d这种方法可用判断key是否存在<br>d.get(‘Thomas’)则可用返回相应的值，若不存在贼返回None，不想返回None也可用自己指定<br>d.get(‘Thomas’,-1)则找不到时返回-1<br>同list，可用pop(key)来删掉元素<br>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。<br>和list比较，dict有以下几个特点：<br>查找和插入的速度极快，不会随着key的增加而变慢；<br>需要占用大量的内存，内存浪费多。<br>而list相反：<br>查找和插入的时间随着元素的增加而增加；<br>占用空间小，浪费内存很少。<br>17.set<br>set和dict类似，但不储存value，只判断是否存在，并且元素不能重复<br>s = set([1, 2, 3])<br>若有重复元素则不会继续添加进set，通过add函数可添加函数<br>remove函数可用删除元素，两个set之间可用做交集，并集操作<br>s1 = set([1, 2, 3])<br>s2 = set([2, 3, 4])<br>s1 &amp; s2<br>{2, 3}<br>s1 | s2<br>{1, 2, 3, 4}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/01/deepin上搭shadowsocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/deepin上搭shadowsocks/" itemprop="url">deepin上搭shadowsocks</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-01T21:31:28+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事先准备:海外服务器一个，chorme浏览器，switchomega插件，linux操作系统基础知识</p>
<p>先说准备：一开始打算去阿里云买的，但是阿里云据说如果搭梯子会警告，24小时还使用就会封停，然后看了下vultr，恩有点贵，再看了隔壁的搬瓦工，虽然便宜，但是只能年费，很多人说用不到一个月就封停，重新申请个还要8刀，说是无底洞，就放弃了，还是老老实实用最稳的vultr。注册个google号，用alipay也就是支付宝充10美元(不能低了坑爹)，然后点主页的加号就可以购买服务器了，2.5刀的虽然有货，但是写了IPV6only，也就是连接服务器的时候只能翻墙才能连。。这不是坑爹么，本来就为了翻墙搭梯子，果断选了3.5刀的那个，服务器我选的是18.04的ubuntu，地点建议选日本，比较快，其他参数随便选。</p>
<p>买好了之后就用ssh或者consoleview连上服务器，然后就是在服务器上安装shadowsock所需的环境。</p>
<p>win上用git bush可以连接，linux直接ctrl+alt+t调出终端进行ssh</p>
<p>1.安装pip</p>
<p>apt-get install python-pip</p>
<p>2.安装:shadowsocks</p>
<p>pip install shadowsocks</p>
<p>3.使用脚本搭建并修改配置文件</p>
<p>git clone <a href="https://github.com/flyzy2005/ss-fly" target="_blank" rel="noopener">https://github.com/flyzy2005/ss-fly</a></p>
<p>ss-fly/ss-fly.sh -i flyzy2005.com 1024</p>
<p>其中flyzy2005.com换成你要设置的shadowsocks的密码即可（这个flyzy2005.com就是你ss的密码了，是需要填在客户端的密码那一栏的），密码随便设置，最好只包含字母+数字，一些特殊字符可能会导致冲突。而第二个参数1024是端口号，也可以不加，不加默认是1024~（举个例子，脚本命令可以是ss-fly/ss-fly.sh -i qwerasd，也可以是ss-fly/ss-fly.sh -i qwerasd 8585，后者指定了服务器端口为8585，前者则是默认的端口号1024，两个命令设置的ss密码都是qwerasd）：</p>
<p>根据自己的配置情况修改配置文件/etc/shadowsocks.json:</p>
<p>单账号配置方法:</p>
<p>{<br>    “server”:”0.0.0.0”,<br>    “server_port”:1080,<br>    “local_address”: “127.0.0.1”,<br>    “local_port”:1080,<br>    “password”:”pwd”,<br>    “timeout”:300,<br>    “method”:”aes-256-cfb”,<br>    “fast_open”: true<br>}</p>
<p>多账号配置方法:</p>
<p>{<br>    “server”:”0.0.0.0”,<br>    “local_address”:”127.0.0.1”,<br>    “local_port”:1080,#本地使用的端口<br>    “port_password”:#配置客户端使用的端口和密码，这里用的是多账号配置<br>    {<br>        “1080”:”pwd1”,#对应的是端口和密码<br>        “1081”:”pwd2”,<br>        “1082”:”pwd3”,<br>        “1083”:”pwd4”,<br>        “1084”:”pwd5”<br>    },<br>    “timeout”:300,#连接超时设置<br>    “method”:”aes-256-cfb”,#加密方式<br>    “fast_open”:true#是否开启加速<br>}<br>4.开启服务</p>
<p>ssserver -c /etc/shadowsocks.json -d start</p>
<p>-d表示在后台运行，如果要停止start改成stop，重启变restart，修改文件要重启才生效</p>
<p>会提示成功开启</p>
<p>5.在客户端使用shadowsocks</p>
<p>win上直接下个shadowsocks的客户端就可以用，手机上也很简单，下个影梭，</p>
<p>然后填上主机ip，分配的端口号和密码就可以用了</p>
<p>deepin上使用稍麻烦:</p>
<p>(1)switchomega插件安装</p>
<p>这个度娘很多教程，以前用xxnet翻墙的时候就搞好了这次就没有重新下，很好用的一个插件</p>
<p>(2)安装shadowsocks</p>
<p>和上面的第一步第二步一样要安装ss环境，此处略</p>
<p>(3)创建配置文件</p>
<p>也是在/etc/中创建一个shadowsocks.json:</p>
<p>{<br>  “server”:”45.76.107.66”,#这里写服务器的ip<br>  “local_address”:”127.0.0.1”,<br>  “local_port”:1081, #这里写分配的端口<br>  “server_port”:1081, #这里和上面的要一致<br>  “password”:”pwd2”, #对应<br>  “timeout”:300,<br>  “method”:”aes-256-cfb”,<br>  “fast_open”: true#开启加速<br>}</p>
<p>(4)运行ss</p>
<p>sslocal -c /etc/shadowsocks.json</p>
<p>(5)配置系统代理</p>
<p>在deepin下面网络右击网络设置，点开系统代理，点手动，修改如下:<br>socks代理:127.0.0.1<br>端口:修改成分配的端口<br>其他默认</p>
<p>(6).完成翻墙</p>
<p>打开chrome，右上角的switchomega调成系统代理，就可以翻墙了</p>
<p>6.BBR加速</p>
<p>ss通过bbr加速可以提高很多的速度</p>
<p>这部分截取自网站:<a href="https://www.dz9.net/blog/4246.html" target="_blank" rel="noopener">https://www.dz9.net/blog/4246.html</a></p>
<p>BBR是个什么东西我就不赘述了，可以理解为和锐速差不多的一个东西，但是呢，锐速过高的价格和不再低端售卖。导致了我们并无法实现一个免费好用的单边加速功能；所以，在这个前提下，咱们现在可以选择BBR（新的 TCP 拥塞控制算法Bottleneck Bandwidth and RTT）。</p>
<p>众所周知，Ubuntu开启BBR的前提是内核必须等于高于4.9，所以想要使用这个牛逼的玩意儿，需要先看看你的内核是否是4.9或者以上。</p>
<p>查看命令：uname -a</p>
<p>如果是4.9或者以上，那么恭喜你，升级内核这一步你就可以跳过了，如果在4.9以下，那就需要更新一下内核了；很遗憾GCE官方默认搭载的镜像，内核是4.4的，所以我必须要做一波内核升级了。</p>
<p>一、Ubuntu内核升级</p>
<p>升级过程中其实比较简单，先确定你的系统是32位还是64位的，可以用下面的命令查看</p>
<p>查看命令：getconf LONG_BIT</p>
<p>确定系统之后，需要下载必要的升级程序包</p>
<p><a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">http://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p>
<p>这个网站可以找到最新的程序包，根据自己的需要使用wget命令来下载到服务器；</p>
<p>比如我的服务器是64位，安装4.10.2的内核：<br>sudo wget <a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb（拥有root权限的话可以去掉命令前面的“sudo”）" target="_blank" rel="noopener">http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb（拥有root权限的话可以去掉命令前面的“sudo”）</a></p>
<p>然后切换到你的文件下载目录，执行下列命令来升级：</p>
<p>sudo dpkg -i linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb</p>
<p>最后，执行命令sudo update-grub，更新grub引导装入程序。</p>
<p>一旦各方面都已完成，重启机器，你就可以准备使用了。系统重启后，打开终端窗口，执行命令uname -a，确保你实际上是在运行你更新之后的内核。</p>
<p>二、开启TCP BBR</p>
<p>修改系统变量：<br>echo “net.core.default_qdisc=fq” &gt;&gt; /etc/sysctl.conf<br>echo “net.ipv4.tcp_congestion_control=bbr” &gt;&gt; /etc/sysctl.conf</p>
<p>重点，执行以上命令，如果显示拒绝访问可以尝试使用如下命令<br>sudo bash -c ‘echo “net.core.default_qdisc=fq” &gt;&gt; /etc/sysctl.conf’<br>sudo bash -c ‘echo “net.ipv4.tcp_congestion_control=bbr” &gt;&gt; /etc/sysctl.conf’</p>
<p>保存生效<br>sysctl -p</p>
<p>执行<br>sysctl net.ipv4.tcp_available_congestion_control</p>
<p>如果返回结果<br>net.ipv4.tcp_available_congestion_control = bbr cubic reno<br>那么恭喜你BBR开启成功了！</p>
<p>也可以执行<br>lsmod | grep bbr<br>来检测 BBR 是否真的开启成功……</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/22/Linux学习笔记-三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/Linux学习笔记-三/" itemprop="url">Linux学习笔记(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T10:48:02+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>61.history<br>    该命令可以查看输入到bash的历史命令，当黑客入侵电脑时通过这个命令，如果使用者平时不注意可能会暴露各种密码，比如mysql的密码<br>62.tab补全命令<br>    之前已经说了tab的补全命令功能，假如想知道c开头的命令，输入c按两下tab键会有提示<br>63.alias别名设置<br>    当我们每次都要以相同的一大串字符命令打头时或者常用命令，可以给其取别名，有点像c中的#define,<br>    alias lm=’ls -al’这样就可以使用lm达到ls -al的效果了<br>64.判断是否为bash shell内置命令指令type<br>    type [不加参|-t|-p|-a] 命令<br>    不加参数时显示是外部指令还是内置指令<br>    -t:返回file表示为外部指令，alies表示该指令为别名，builtin表示为bash内置指令<br>    -p:后面接外部指令时才会显示完整文件名<br>    -a:会有PATH变量路径中查找包含该字段的命令都找出来<br>65.ssh远程登录<br>    ssh [-p 端口号] <a href="mailto:root@127.0.0.1" target="_blank" rel="noopener">root@127.0.0.1</a><br>    端口号可不填，root处填用户名，@后面填服务器ip<br>66.yum命令<br>    centos自带的软件包管理系统，常用命令:<br>        列出所有可更新软件yum:check-update:<br>        更新所有软件:yum update<br>        安装软件:yum install 软件包名<br>        列出所有可安装软件清单:yum list<br>        删除软件包:yum remove 软件包名<br>        查找软件包:yum search 软件包名<br>        清除缓存:yum clean<br>67.shell脚本<br>    shell脚本种类众多，常见的有Bourne shell,扩展名为sh，第一行一般是这样:</p>
<pre><code>    #!/bin/bash 这句话的意思为告诉系统该脚本需要什么解释器来执行
运行脚本的方法:
    脚本需要有可执行的权限:
    chmod +x ./test.sh #使脚本有权限
    ./test.sh #执行脚本
</code></pre><p>68.shell变量<br>    变量的定义:var_name=”test”<br>    注意:<br>        变量名和等号间不能有空格，命名只能使用英文字母，数字，下划线<br>        首个字符不能数字打头，中间不能有空格，不能使用标点符号，不能<br>        使用关键字，关键字可以输入help查看<br>    还可以用语句给变量赋值：<br>        for file in ‘ls /etc’<br>        将把etc中的文件名循环出来<br>    使用变量:<br>        在变量名前加美元符号:<br>            echo $var_name或${var_name}<br>            就将显示出刚刚定义的内容test,花括号可不加，为帮助解释器识别边界<br>    只读变量:<br>        使用readonly命令可以定义只读变量，改变只读变量时，结果报错</p>
<pre><code>        #!/bin/bash
        myurl=&quot;http://www.baidu.com&quot;
        readonly myurl
删除变量:
    使用unset可以删除变量:
        unset myurl
变量类型:
    局部变量:仅在当前shell中有效，其他shell不能访问
    环境变量:所有的程序都能访问的变量
    shell变量:由shell程序设置的特殊变量，shell变量中有一部分为局部变量，有一部分为环境变量
</code></pre><ol start="69">
<li>shell字符串:<br> 单引号:单引号中任何字符都会原样输出，单引号字串中不能出现单引号<pre><code>str=&apos;this is a string&apos;
</code></pre> 双引号:双引号中可以有变量和转移字符，将被替代输出<pre><code>name=&apos;zz&apos;
str=&quot;hello world by $name&quot;
</code></pre> 获得字符串长度:<pre><code>string=&quot;abcd&quot;
echo ${#string} #输出4
</code></pre> 提取子字符串:<pre><code>string=&quot;this is a test&quot;
echo ${string:1:4} #输出his空格
</code></pre> 查找子字符串:<pre><code>string=&quot;this is a test&quot;
echo `expr index &quot;$string&quot; is`#输出3
会查找字串中第一个出现i或者s的位置(从1开始)
</code></pre>70.shell数组<br> Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小，数组元素的下标由0开始。<br> 定义数组:<pre><code>array_name(v1 v2 v3)或array_name=(v1 v2 v3 v4)或array_name[0]=v1,array_name[1]=v2...
</code></pre> 读取数组:<pre><code>echo ${array_name[@]}读取所有元素
echo ${array_name[0]}读取单个元素
</code></pre> 获取数组长度:<pre><code>和获取字串长度相同: echo ${#array_name[@]}
</code></pre> 注释:<pre><code>#这是一个注释
</code></pre> 多行注释:<pre><code>:&lt;&lt;EOF
注释内容...
注释内容...
注释内容...
EOF
其中EOF可以用其他符号代替，如!和&apos;
</code></pre>71.shell传参:<pre><code>test.sh内容:
    #!/bin/bash
    echo &quot;执行文件名:$0&quot;;
    echo &quot;第一个参数:$1&quot;;
    echo &quot;第二个参数:$2&quot;;
    echo &quot;第三个参数:$3&quot;;
外部:
    给予权限:
        chmod +x test.sh
    传递参数:
        ./test.sh 1 2 3
    执行:
        ./test.sh
    结果:
        执行文件名:test.sh;
        第一个参数:1;
        第二个参数:2;
        第三个参数:3;
    脚本特殊符号:
        $#:传递到脚本的参数个数
        $*:以一个字串的形式显示所有向脚本传递的参数
        $$:显示脚本运行的当前进程ID号
        $!:后台运行的最后一个进程的ID号
        $@:与$*相同，不同的是以多个字串的形式输出所有参数
        $-:显示shell当前选项，与set命令功能相同
        $?:显示最后命令的退出状态，0表示没有错误，其他值为有错误
    $* 与 $@ 区别：
        相同点：都是引用所有参数。
        不同点：只有在双引号中体现出来。
        假设在脚本运行时写了三个参数 1、2、3，
        则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数
        而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）
</code></pre>72.shell基本运算符<pre><code>原生的bash不支持简单的数学运算，需要通过一些命令来实现
        算术运算符:
                expr是算术表达式的工具，能完成表达式的求值
                注意使用的是反引号不是单引号
                脚本:
                #!/bin/bash
                val=`expr 2 + 2`
                echo &quot;两数之和为:$val&quot;
        注意运算符和数字之间要有空格，同样支持+，-，*，/，%，=，==，!=运算
        条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]
        乘号(*)前边必须加反斜杠(\)才能实现乘法运算
</code></pre>73.shell关系运算符<br> 用法:<pre><code>[ $a 运算符 $b]
</code></pre> 符号:<pre><code>-eq:检测两个数是否相等，相等返回 true
-ne:检测两个数是否不相等，不相等返回 true
-gt:检测左边的数是否大于右边的，如果是，则返回 true
-lt:检测左边的数是否小于右边的，如果是，则返回 true
-ge:检测左边的数是否大于等于右边的，如果是，则返回 true
-le:检测左边的数是否小于等于右边的，如果是，则返回 true
</code></pre> 布尔运算符:<pre><code>!:非运算
-o:或运算
-a:与运算
</code></pre> 逻辑运算符:<pre><code>&amp;&amp;:逻辑AND
||:逻辑OR
</code></pre> 字符运算符:<pre><code>=:检测两个字符串是否相等，相等返回 true
!=:检测两个字符串是否相等，不相等返回 true
-z:检测字符串长度是否为0，为0返回 true
-n:检测字符串长度是否为0，不为0返回 true
str:检测字符串是否为空，不为空返回 true
</code></pre> 文件测试运算符:<pre><code>-d file:检测文件是否是目录，如果是，则返回 true
-f file:检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true
-u file:检测文件是否设置了 SUID 位，如果是，则返回 true
-r file:检测文件是否可读，如果是，则返回 true
-w file:检测文件是否可写，如果是，则返回 true
-x file:检测文件是否可执行，如果是，则返回 true
-s file:检测文件是否为空（文件大小是否大于0），不为空返回 true
-e file:检测文件（包括目录）是否存在，如果是，则返回 true
</code></pre>74.echo命令<br> 该命令用于显示字符串，要显示转义字符时加\，加上参数-e表示开启转义<br> \n表示换行,\c表示不换行<br> 定向文件输出:<pre><code>echo &quot;this is a test&quot; &gt; myfile
</code></pre> 显示命令执行结果(注意为反引号):<pre><code>echo `date`
</code></pre>75.printf命令<br> 作用和echo差不多，不同在于printf可以格式化输出，并且不会自动添加换行符<br> 用法和c语言类似<br> eg:<pre><code>    #!/bin/bash
    printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
    printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
    printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
    printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876
结果:
    姓名     性别   体重kg
    郭靖     男              66.12
    杨过     男              48.65
    郭芙     女              47.99
</code></pre>76.控制语句<br> 和c语言有些相似又有些不同:<br> eg:<pre><code>a=10
b=20
if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
elif [ $a -gt $b ]
then
   echo &quot;a 大于 b&quot;
elif [ $a -lt $b ]
then
   echo &quot;a 小于 b&quot;
else
   echo &quot;没有符合的条件&quot;
fi
</code></pre>77.循环语句<br> 和py有点类似<br> for语句:<br> eg:<pre><code>for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done
</code></pre> while语句:<br> eg:<pre><code>#!/bin/bash
int=1
while(( $int&lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done
</code></pre> 使用中使用了 Bash let 命令，它用于执行一个或多个表达式<br> 变量计算中不需要加上 $ 来表示变量<br> 无限循环<br> 语法格式：<pre><code>while :
do
    command
done
或者
while true
do
    command
done
或者
for (( ; ; ))
</code></pre> until 循环<br> until 循环执行一系列命令直至条件为 true 时停止<br> until 循环与 while 循环在处理方式上刚好相反<br> eg:<pre><code>#!/bin/bash
a=0
until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
</code></pre>78.选择语句:<br> 取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。<br> 匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。<br> 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。<br> 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。<br> eg:<pre><code>echo &apos;输入 1 到 4 之间的数字:&apos;
echo &apos;你输入的数字为:&apos;
read aNum
case $aNum in
    1)  echo &apos;你选择了 1&apos;
    ;;
    2)  echo &apos;你选择了 2&apos;
    ;;
    3)  echo &apos;你选择了 3&apos;
    ;;
    4)  echo &apos;你选择了 4&apos;
    ;;
    *)  echo &apos;你没有输入 1 到 4 之间的数字&apos;
    ;;
esac
</code></pre>79.结束跳出循环<br> break,continue的用法和c语言一样<br> esac是case反过来，表示case的结束标志<br>80.shell函数<br> 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数<br> 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值<br> return后跟数值n(0-255<br> eg:<pre><code>#!/bin/bash
funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;
</code></pre> 函数返回值在调用该函数后通过 $? 来获得<br> 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用<br> 调用函数仅使用其函数名即可<br> 函数传参数直接函数名后面跟数据就行<br> eg:<pre><code>#!/bin/bash
funWithParam(){
    echo &quot;第一个参数为 $1 !&quot;
    echo &quot;第二个参数为 $2 !&quot;
    echo &quot;第十个参数为 $10 !&quot;
    echo &quot;第十个参数为 ${10} !&quot;
    echo &quot;第十一个参数为 ${11} !&quot;
    echo &quot;参数总数有 $# 个!&quot;
    echo &quot;作为一个字符串输出所有参数 $* !&quot;
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
</code></pre>81.shell输入输出重定向<br> 命令通常从一个叫标准输入输出的地方读取输入输出<br> 默认情况下是终端<br> 可以通过插入符号改变输入输出方向到文件<br> 命令:<pre><code>command &gt; file    将输出重定向到 file
command &lt; file    将输入重定向到 file
command &gt;&gt; file    将输出以追加的方式重定向到 file
n &gt; file    将文件描述符为 n 的文件重定向到 file
n &gt;&gt; file    将文件描述符为 n 的文件以追加的方式重定向到 file
n &gt;&amp; m    将输出文件 m 和 n 合并
n &lt;&amp; m    将输入文件 m 和 n 合并
&lt;&lt; tag    将开始标记 tag 和结束标记 tag 之间的内容作为输入
</code></pre>82.shell文件包含<br> shell可以包含外部脚本,类似于c语言的include<br> 用法:<pre><code>. filename   # 注意点号(.)和文件名中间有一空格
或
source filename
</code></pre>83.查看本机ip:<br> ifconfig<br>84.查看linux版本<br> cat /proc/version<br>85.查看所有进程<br> ps -ef<br>86.终止进程<br> kill -9 ID号<br>87.查看磁盘剩余空间<br> df<br>88.scp命令<br> 在A服务器(可以认为自己的电脑)上操作，将B（服务器140.143.12.345)<br> 在自己的电脑终端上操作，用于把服务器端的文件传到自己电脑上：<pre><code>scp -r root@140.143.12.345:/home /root
</code></pre> 在A服务器(自己的电脑上)将/root目录下所有的文件传输到B（服务器）的/home目录下：<pre><code>scp -r /root root@140.143.12.345:/home
</code></pre>89.grep命令<br> grep是一个强大的文本搜索工具，可以以正则表达式的形式进行文本搜索<br> 用法:<pre><code>grep [参数] 内容名 文件名
</code></pre> 参数:<br> -a 不要忽略二进制数据。<br> -A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。<br> -b 在显示符合范本样式的那一行之外，并显示该行之前的内容。<br> -c 计算符合范本样式的列数。<br> -C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。<br> -d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。<br> -e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。<br> -E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。<br> -f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。<br> -F 将范本样式视为固定字符串的列表。<br> -G 将范本样式视为普通的表示法来使用。<br> -h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。<br> -H 在显示符合范本样式的那一列之前，标示该列的文件名称。<br> -i 忽略字符大小写的差别。<br> -l 列出文件内容符合指定的范本样式的文件名称。<br> -L 列出文件内容不符合指定的范本样式的文件名称。<br> -n 在显示符合范本样式的那一列之前，标示出该列的编号。<br> -q 不显示任何信息。<br> -R/-r 此参数的效果和指定“-d recurse”参数相同。<br> -s 不显示错误信息。<br> -v 反转查找。<br> -w 只显示全字符合的列。<br> -x 只显示全列符合的列。<br> -y 此参数效果跟“-i”相同。<br> -o 只输出文件中匹配到的部分。<br>90.wget命令<br> 该命令用于url下载文件</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/Linux学习笔记-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/Linux学习笔记-二/" itemprop="url">Linux学习笔记(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T11:56:26+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          《鸟哥的Linux私房菜》读书笔记
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/07/11/Linux学习笔记-二/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/06/暑假计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/06/暑假计划/" itemprop="url">暑假计划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T18:44:50+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>希望这个暑假过得有意义~<br>计划：<br>    每天7:20起，看书，完成：<br>        一阶段：linux基础，springboot使用，python基础（能写脚本），nginx，docker<br>        二阶段：java虚拟机，redis<br>        三阶段：java分布式，java多线程，java并发<br>        另外的闲书+复习：css5，html5，tomcat，io流，异常处理，反射机制，代理机制，计算机网络，集合框架源码，ssm框架源码，数据库调优，剑指offer<br>    中午吃完饭适当休息进行码代码训练，做web工程+牛客网，leetcode刷题保持手感，或者不困继续看书<br>    6:00结束学习～开始嗨（很怕我只进行这一步）<br>    每天跑步半小时～<br>    每天0点左右睡觉<br>还有很多东西要学，共勉<br>ps:<br>    我发现hexo每个冒号后面必须要空一格要不然会报错emmm找了半个小时的错才想起来</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/06/Linux学习笔记-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/06/Linux学习笔记-一/" itemprop="url">Linux学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T18:19:03+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          《鸟哥的Linux私房菜》读书笔记
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/07/06/Linux学习笔记-一/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/04/Hexo/" itemprop="url">使用github搭建Hexo博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-04T21:49:41+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>今天搞了一晚上搭建Hexo博客，发现异常得简单～写篇博客记录下</p>
<p>搭建博客的框架有很多，学长用的是WordPress，今天拿了Hexo练了下手。</p>
<p>首先这个博客框架是用node.js写的，首先就是安装node.js的环境</p>
<hr>
<p>linux系统很简单，终端输入：</p>
<p>sudo apt-get install nodejs</p>
<p>sudo apt-get install npm(安装版本管理工具)</p>
<p>就安装好环境了，查看有没有安装好的方法：</p>
<p>node -v会显示node.js版本号</p>
<p>npm -v会显示工具的版本号</p>
<p>windows下就百度一下应该也蛮简单，只是linux连环境变量都不用配置hhhh</p>
<hr>
<p>由于这个框架是github托管的，自然就要安装git了linux直接sudo apt-get install git就行，windows下安装git bush</p>
<p>然后就创建个文件夹作为存放博客文件的仓库，接下来就要去github上创建一个仓库了。</p>
<p>github真良心。。登录github点击加号创建仓库，然后把仓库名字取为:你的id.github.io</p>
<p>比如我的名字是iunique，仓库名字像这样：</p>
<p>然后点确定。。这样这个域名就属于你的了，每个账号允许注册一个这种域名</p>
<p>创建成功后就可以在地址栏输入iunique.github.io就可以访问你的域名了</p>
<p>下面说一下我学到的基本的上传文章操作：</p>
<p>在你准备好的仓库里面，如果是windows就git bush here</p>
<p>linux直接在文件处打开终端</p>
<hr>
<p>安装hexo：</p>
<p>npm intall hexo -g</p>
<p>等一会hexo就安装好了</p>
<p>命令：hexo -v  查看是否成功</p>
<p>命令：hexo init  等待大概几分钟就初始化好了</p>
<p>命令：npm install  会安装各种组件</p>
<p>命令: hexo g  会部署hexo博客</p>
<p>命令hexo s  开启服务器</p>
<p>之后会提示在localhost:4000可以访问页面了，如果访问失败可能是4000端口没有打开：</p>
<p>ctrl+c停止后修改端口：</p>
<p>hexo server -p  端口号</p>
<p>之后，如果以前在该服务器上加入过ssh key到你的github账号上就可以直接跳过这一步：</p>
<hr>
<p>安装完git后：cd ~/.ssh</p>
<p>ssh-keygen -t rsa -C “这里填写你的邮箱地址”</p>
<p>会在该文件下生成秘钥,</p>
<p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent,</p>
<p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH到ssh-agent</p>
<p>来到github页面，点setting，吧id_rsa里的东西复制进ssh keys里，title随便打</p>
<p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，显示hi+你id就说明添加成功了</p>
<hr>
<p>部署hexo：</p>
<p>来到你的仓库，有个_config.yml，用编辑器打开，来到最后几行，修改：</p>
<p>repository后面的是你的仓库的ssh key,注意冒号后面要打空格，我一开始就是少打了空格所以没有部署成功</p>
<p>输入命令：</p>
<p>hexo new post “文章名”</p>
<p>在该文件下的source下的_post目录下会生成文章文件</p>
<p>用编辑器打开就可以进行文章编辑了，这个有严格的格式要求：</p>
<hr>
<p>title: title #文章标题<br>date: 2018-06-04 22:45:44 #文章生成时间<br>categories: “分类” #文章分类目录，可略<br>tags: #文章标签 可略</p>
<h2 id="description-本文描述-可略"><a href="#description-本文描述-可略" class="headerlink" title=" description: #本文描述 可略"></a> description: #本文描述 可略</h2><p>这个横线下面填文章内容</p>
<p>输入安装扩展：</p>
<p>npm install hexo-deployer-git –save</p>
<p>输入生成文件以及部署：</p>
<p>hexo d -g</p>
<p>然后你就可以输入域名看见刚刚写好的文章了：</p>
<p><a href="https://iunique.github.io" target="_blank" rel="noopener">https://iunique.github.io</a></p>
<p>ps:如果没有效果在iunique.github.io仓库下的setting看看是不是域名填错了</p>
<p>要为iunique.github.io这种格式（想要绑定其他的域名应该也可以设置）</p>
<p>还有就是_config.yml中数据填错了</p>
<p>附上我搭好的hexo博客：</p>
<p><a href="https://iunique.github.io" target="_blank" rel="noopener">https://iunique.github.io</a></p>
<p>下面是我摘录的一些hexo的命令～过几天有时间好好学怎么布置装扮hexo博客</p>
<p>参考网站：</p>
<p><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></p>
<p>hexo</p>
<p>npm install hexo -g #安装<br>npm update hexo -g #升级<br>hexo init #初始化<br>简写</p>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo p == hexo publish<br>hexo g == hexo generate#生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy#部署</p>
<p>服务器</p>
<p>hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP</p>
<p>hexo clean #清除缓存 网页正常情况下可以忽略此条命令<br>hexo g #生成静态网页<br>hexo d #开始部署</p>
<p>监视文件变动</p>
<p>hexo generate #使用 Hexo 生成静态文件快速而且简单<br>hexo generate –watch #监视文件变动</p>
<p>完成后部署</p>
<p>两个命令的作用是相同的<br>hexo generate –deploy<br>hexo deploy –generate</p>
<p>hexo deploy -g<br>hexo server -g</p>
<p>草稿</p>
<p>hexo publish [layout] <title></title></p>
<p>模版</p>
<p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub</p>
<p>hexo new [layout] <title><br>hexo new photo “My Gallery”<br>hexo new “Hello World” –lang tw</title></p>
<p>变量    描述<br>layout    布局<br>title    标题<br>date    文件建立日期<br>title: 使用Hexo搭建个人博客<br>layout: post<br>date: 2014-03-03 19:07:43<br>comments: true<br>categories: Blog<br>tags: [Hexo]<br>keywords: Hexo, Blog<br>description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。<br>模版（Scaffold）</p>
<p>hexo new photo “My Gallery”</p>
<p>变量    描述<br>layout    布局<br>title    标题<br>date    文件建立日期<br>设置文章摘要</p>
<p>以上是文章摘要
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/06/04/Hexo/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpeg"
                alt="hjy" />
            
              <p class="site-author-name" itemprop="name">hjy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hjy</span>

  
</div>


  <div class="powered-by">
  <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
